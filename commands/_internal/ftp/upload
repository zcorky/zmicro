#!/bin/bash

help() {
  echo "FTP Upload"
  echo ""
  echo "Usage:"
  echo "  zmicro ftp upload"
  echo ""
  echo "Environment Variables:"
  echo "  FTP_HOST - FTP 主机地址"
  echo "  FTP_PORT - FTP 端口"
  echo "  FTP_USER - FTP 用户名"
  echo "  FTP_PASS - FTP 密码"
  echo "  REMOTE_DIR - 远程目标目录"
  echo "  LOCAL_DIR - 本地当前目录"
  echo "  IGNORE_DIR_OR_FILES - 忽略的文件和目录"
  echo "  LOG_LEVEL - 日志级别 (INFO/DEBUG, 默认 INFO, DEBUG 会显示详细的文件对比信息)"
}

core() {
  if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    help
    exit 0
  fi

  # check and install lftp
  if [ "$(os::has_command lftp)" = "false" ]; then
    pm install -y lftp
  fi

  local FTP_HOST=${FTP_HOST} # FTP 主机地址
  local FTP_PORT=${FTP_PORT:-21} # FTP 端口
  local FTP_USER=${FTP_USER} # FTP 用户名
  local FTP_PASS=${FTP_PASS} # FTP 密码
  local REMOTE_DIR=${REMOTE_DIR:-/}  # 远程目标目录
  local LOCAL_DIR=${LOCAL_DIR:-./}                   # 本地当前目录
  local IGNORE_DIR_OR_FILES=${IGNORE_DIR_OR_FILES:-".git .env .settings .vendor .buildpath .project"} # 忽略的文件和目录
  local LOG_LEVEL=${LOG_LEVEL:-INFO} # 日志级别 (INFO/DEBUG)
  
  # Debug log function
  debug_log() {
    if [ "$LOG_LEVEL" = "DEBUG" ]; then
      log::info "[$(timestamp)][ftp][DEBUG] $@"
    fi
  }

  if [ -z "$FTP_HOST" ]; then
    log::error "[$(timestamp)][ftp] FTP_HOST is not set."
    exit 1
  fi

  if [ -z "$FTP_USER" ]; then
    log::error "[$(timestamp)][ftp] FTP_USER is not set."
    exit 1
  fi

  if [ -z "$FTP_PASS" ]; then
    log::error "[$(timestamp)][ftp] FTP_PASS is not set."
    exit 1
  fi

  if [ -z "$REMOTE_DIR" ]; then
    log::error "[$(timestamp)][ftp] REMOTE_DIR is not set."
    exit 1
  fi

  if [ -z "$LOCAL_DIR" ]; then
    log::error "[$(timestamp)][ftp] LOCAL_DIR is not set."
    exit 1
  fi

  if [ -z "$IGNORE_DIR_OR_FILES" ]; then
    log::error "[$(timestamp)][ftp] IGNORE_DIR_OR_FILES is not set."
    exit 1
  fi

  log::info "[$(timestamp)][ftp] start upload"

  log::info "[$(timestamp)][ftp] LOCAL_DIR: $LOCAL_DIR"
  log::info "[$(timestamp)][ftp] REMOTE_DIR: $REMOTE_DIR"
  log::info "[$(timestamp)][ftp] IGNORE_DIR_OR_FILES: $IGNORE_DIR_OR_FILES"
  log::info "[$(timestamp)][ftp] LOG_LEVEL: $LOG_LEVEL"

  # Detect hash command for content verification (Mac/Linux compatible)
  local hash_cmd=""
  local hash_cmd_type=""
  if command -v md5sum >/dev/null 2>&1; then
    hash_cmd="md5sum"
    hash_cmd_type="md5sum"  # Output: hash  filename
  elif command -v md5 >/dev/null 2>&1; then
    hash_cmd="md5"
    hash_cmd_type="md5"     # Output: MD5 (filename) = hash
  fi

  # Function to calculate file hash (works on both Mac and Linux)
  calc_file_hash() {
    local file="$1"
    if [ -z "$hash_cmd" ] || [ ! -f "$file" ]; then
      echo ""
      return
    fi
    
    if [ "$hash_cmd_type" = "md5sum" ]; then
      # Linux: md5sum outputs "hash  filename"
      $hash_cmd "$file" 2>/dev/null | cut -d' ' -f1
    elif [ "$hash_cmd_type" = "md5" ]; then
      # Mac: md5 outputs "MD5 (filename) = hash", use -q for quiet mode (hash only)
      $hash_cmd -q "$file" 2>/dev/null
    else
      echo ""
    fi
  }

  # Function to restore file timestamps from git (most accurate method)
  # Returns: 0 if successful, 1 if failed or not applicable
  restore_git_timestamps() {
    local target_dir="$1"
    local restored_count=0
    local total_files=0
    
    # Check if git repository exists and git command is available
    if [ ! -d "$target_dir/.git" ] || ! command -v git >/dev/null 2>&1; then
      debug_log "Not a git repository or git not available, skipping timestamp restoration"
      return 1
    fi
    
    log::info "[$(timestamp)][ftp] Detected git repository, restoring file timestamps from git..."
    
    # Change to target directory
    cd "$target_dir" 2>/dev/null
    if [ "$?" != "0" ]; then
      log::info "[$(timestamp)][ftp] Failed to change to directory: $target_dir"
      return 1
    fi
    
    # Restore timestamps for all tracked files
    # Use process substitution to avoid subshell issue with variable counting
    while IFS= read -r file; do
      if [ -f "$file" ]; then
        total_files=$((total_files + 1))
        # Get last modification time from git
        local git_time=$(git log -1 --format=%ct -- "$file" 2>/dev/null)
        if [ -n "$git_time" ]; then
          # Restore file timestamp (Mac and Linux use different commands)
          if [ "$(uname -s)" = "Darwin" ]; then
            # Mac: use touch -t with date conversion
            local date_str=$(date -r "$git_time" +%Y%m%d%H%M.%S 2>/dev/null)
            if [ -n "$date_str" ]; then
              touch -t "$date_str" "$file" 2>/dev/null
              if [ "$?" = "0" ]; then
                restored_count=$((restored_count + 1))
                debug_log "Restored timestamp for: $file (git time: $git_time)"
              fi
            fi
          else
            # Linux: use touch -d with @timestamp
            touch -d "@$git_time" "$file" 2>/dev/null
            if [ "$?" = "0" ]; then
              restored_count=$((restored_count + 1))
              debug_log "Restored timestamp for: $file (git time: $git_time)"
            fi
          fi
        fi
      fi
    done < <(git ls-files 2>/dev/null)
    
    # Return to original directory
    cd - >/dev/null 2>&1
    
    # Check if restoration was successful
    if [ "$restored_count" -gt 0 ]; then
      log::info "[$(timestamp)][ftp] Restored timestamps for $restored_count files from git"
      return 0
    else
      log::info "[$(timestamp)][ftp] No files found in git or failed to restore timestamps"
      return 1
    fi
  }

  # Strategy 1: Try to restore file timestamps from git (most accurate)
  local git_restore_success=false
  if restore_git_timestamps "$LOCAL_DIR"; then
    git_restore_success=true
  fi

  # Build exclude arguments for mirror command
  # lftp mirror --exclude-glob pattern matches files/directories
  # For directories, we need both the directory name and its contents pattern
  # Note: --delete is removed to prevent deleting other files on remote server
  #
  # How lftp mirror does incremental update:
  # 1. lftp uses FTP protocol to get remote file size and modification time (MDTM command)
  # 2. Compares with local file size and modification time
  # 3. Only uploads if size OR time is different
  # 4. This works even in new containers because it queries the remote server each time
  # 5. No local cache needed - all comparisons are done via FTP protocol in real-time
  #
  # File comparison strategy:
  # 1. If git timestamps restored successfully, use size+time comparison (most accurate)
  # 2. If git restore failed or not in git repo, use --ignore-time but verify with hash
  #    for files with same size to ensure content is actually the same
  #
  # --parallel=N: upload N files in parallel (default 1, increase for speed)
  # --use-cache: use cache to speed up directory listings (lftp's internal cache)
  local mirror_options="--parallel=3 --use-cache --verbose"
  if [ "$git_restore_success" != "true" ]; then
    # Git restore failed, use --ignore-time (size-only comparison)
    mirror_options="--ignore-time $mirror_options"
    log::info "[$(timestamp)][ftp] Using size-only comparison (git timestamps not restored)"
    # Strategy 2: Warn about size-only comparison limitations
    if [ -n "$hash_cmd" ]; then
      log::info "[$(timestamp)][ftp] Note: Files with same size but different content may be skipped"
      log::info "[$(timestamp)][ftp] Recommendation: Use git repository to restore timestamps for accurate comparison"
      debug_log "Hash command available but not used (would require downloading remote files for verification)"
    else
      log::info "[$(timestamp)][ftp] Note: Files with same size but different content may be skipped"
    fi
  else
    log::info "[$(timestamp)][ftp] Using size+time comparison (git timestamps restored)"
  fi

  local mirror_cmd="mirror -R $mirror_options"
  
  # Add user-specified ignore patterns
  if [ -n "$IGNORE_DIR_OR_FILES" ]; then
    for pattern in $IGNORE_DIR_OR_FILES; do
      mirror_cmd="$mirror_cmd --exclude-glob $pattern"
      mirror_cmd="$mirror_cmd --exclude-glob $pattern/**"
    done
  fi
  mirror_cmd="$mirror_cmd $LOCAL_DIR ."
  
  debug_log "Final mirror command: $mirror_cmd"

  # Build lftp command with port
  # Use full path to lftp to avoid command not found issues
  local lftp_bin=$(command -v lftp)
  if [ -z "$lftp_bin" ]; then
    log::error "[$(timestamp)][ftp] lftp command not found in PATH."
    exit 1
  fi
  local lftp_cmd="$lftp_bin -u $FTP_USER,$FTP_PASS -p $FTP_PORT $FTP_HOST"
  
  # Build directory creation commands for REMOTE_DIR and its parents
  # Strategy: create directories level by level, but suppress error output
  # Since lftp doesn't support conditional execution, we create all levels
  # but errors are suppressed by redirecting stderr
  local dir_commands=""
  if [ "$REMOTE_DIR" != "/" ]; then
    # Split the path and handle each level
    IFS='/' read -ra ADDR <<< "$REMOTE_DIR"
    local current_path=""
    for part in "${ADDR[@]}"; do
      if [ -n "$part" ]; then
        if [ -z "$current_path" ]; then
          # Handle absolute path starting with /
          if [[ "$REMOTE_DIR" == /* ]]; then
            current_path="/$part"
          else
            current_path="$part"
          fi
        else
          current_path="$current_path/$part"
        fi
        # Create directory - errors will be suppressed by cmd:fail-exit false
        # and we'll redirect output in the lftp session
        dir_commands="${dir_commands}mkdir \"$current_path\""$'\n'
      fi
    done
  fi
  
  # Execute lftp upload using heredoc (lftp doesn't support -f option)
  # Redirect stderr to suppress mkdir errors for existing directories
  $lftp_cmd 2>/dev/null <<EOF
set ftp:list-options -a
set ssl:verify-certificate no
set cmd:fail-exit false
# Enable cache and incremental transfer settings
set cache:enable true
# Don't clobber - let mirror -n decide if file needs update
set xfer:clobber false
set xfer:use-temp-file false
# File comparison settings
# lftp mirror compares file size and/or modification time via FTP protocol
# - ftp:use-mdtm: use MDTM command to get remote file modification time
# - ftp:use-feat: use FEAT command to check server capabilities
# - lftp queries remote server for each file's size and time, then compares with local
# - If git timestamps restored: uses size+time comparison (most accurate)
# - If not: uses --ignore-time (size only) - note: may miss files with same size but different content
# - This is a real-time comparison via FTP protocol, no local cache needed
set ftp:use-mdtm true
set ftp:use-feat true
# Comparison behavior depends on git timestamp restoration
# If restored: size+time comparison (most accurate)
# If not: size-only comparison (less accurate but works without git)
# Create parent directories if needed (errors suppressed for existing dirs)
${dir_commands}
# Change to the remote directory
cd "$REMOTE_DIR"
# Execute mirror command
$mirror_cmd
quit
EOF

  local lftp_exit_code=$?
  
  if [ "$lftp_exit_code" != "0" ]; then
    log::error "[$(timestamp)][ftp] failed to upload."
    exit 1
  fi

  # Strategy 3: Optional hash verification for uploaded files (if hash command available)
  # This verifies that uploaded files match local files (for debugging/verification)
  # Note: This is optional and only runs if hash command is available and LOG_LEVEL is DEBUG
  if [ "$LOG_LEVEL" = "DEBUG" ] && [ -n "$hash_cmd" ] && [ "$git_restore_success" != "true" ]; then
    log::info "[$(timestamp)][ftp] DEBUG: Hash verification available but skipped (would require downloading files)"
    log::info "[$(timestamp)][ftp] DEBUG: For maximum accuracy, use git repository to restore timestamps"
    debug_log "Hash verification skipped: FTP protocol doesn't support direct hash retrieval"
  fi

  log::success "[$(timestamp)][ftp] succeed to upload."
}

run() {
  core $@
}

run $@
