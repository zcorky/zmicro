#!/bin/bash

help() {
  echo "FTP Upload"
  echo ""
  echo "Usage:"
  echo "  zmicro ftp upload"
  echo ""
  echo "Environment Variables:"
  echo "  FTP_HOST - FTP 主机地址"
  echo "  FTP_PORT - FTP 端口"
  echo "  FTP_USER - FTP 用户名"
  echo "  FTP_PASS - FTP 密码"
  echo "  REMOTE_DIR - 远程目标目录"
  echo "  LOCAL_DIR - 本地当前目录"
  echo "  IGNORE_DIR_OR_FILES - 忽略的文件和目录"
  echo "  LOG_LEVEL - 日志级别 (INFO/DEBUG, 默认 INFO, DEBUG 会显示详细的文件对比信息)"
}

core() {
  if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    help
    exit 0
  fi

  # check and install lftp
  if [ "$(os::has_command lftp)" = "false" ]; then
    pm install -y lftp
  fi

  local FTP_HOST=${FTP_HOST} # FTP 主机地址
  local FTP_PORT=${FTP_PORT:-21} # FTP 端口
  local FTP_USER=${FTP_USER} # FTP 用户名
  local FTP_PASS=${FTP_PASS} # FTP 密码
  local REMOTE_DIR=${REMOTE_DIR:-/}  # 远程目标目录
  local LOCAL_DIR=${LOCAL_DIR:-./}                   # 本地当前目录
  local IGNORE_DIR_OR_FILES=${IGNORE_DIR_OR_FILES:-".git .env .settings .vendor .buildpath .project"} # 忽略的文件和目录
  local LOG_LEVEL=${LOG_LEVEL:-INFO} # 日志级别 (INFO/DEBUG)
  
  # Debug log function
  debug_log() {
    if [ "$LOG_LEVEL" = "DEBUG" ]; then
      log::info "[$(timestamp)][ftp][DEBUG] $@"
    fi
  }

  if [ -z "$FTP_HOST" ]; then
    log::error "[$(timestamp)][ftp] FTP_HOST is not set."
    exit 1
  fi

  if [ -z "$FTP_USER" ]; then
    log::error "[$(timestamp)][ftp] FTP_USER is not set."
    exit 1
  fi

  if [ -z "$FTP_PASS" ]; then
    log::error "[$(timestamp)][ftp] FTP_PASS is not set."
    exit 1
  fi

  if [ -z "$REMOTE_DIR" ]; then
    log::error "[$(timestamp)][ftp] REMOTE_DIR is not set."
    exit 1
  fi

  if [ -z "$LOCAL_DIR" ]; then
    log::error "[$(timestamp)][ftp] LOCAL_DIR is not set."
    exit 1
  fi

  if [ -z "$IGNORE_DIR_OR_FILES" ]; then
    log::error "[$(timestamp)][ftp] IGNORE_DIR_OR_FILES is not set."
    exit 1
  fi

  log::info "[$(timestamp)][ftp] start upload"

  log::info "[$(timestamp)][ftp] LOCAL_DIR: $LOCAL_DIR"
  log::info "[$(timestamp)][ftp] REMOTE_DIR: $REMOTE_DIR"
  log::info "[$(timestamp)][ftp] IGNORE_DIR_OR_FILES: $IGNORE_DIR_OR_FILES"
  log::info "[$(timestamp)][ftp] LOG_LEVEL: $LOG_LEVEL"

  # Build exclude arguments for mirror command
  # lftp mirror --exclude-glob pattern matches files/directories
  # For directories, we need both the directory name and its contents pattern
  # Note: --delete is removed to prevent deleting other files on remote server
  #
  # How lftp mirror does incremental update:
  # 1. lftp uses FTP protocol to get remote file size and modification time (MDTM command)
  # 2. Compares with local file size and modification time
  # 3. Only uploads if size OR time is different
  # 4. This works even in new containers because it queries the remote server each time
  # 5. No local cache needed - all comparisons are done via FTP protocol in real-time
  #
  # Default behavior: compare both file size AND modification time
  # Only upload if size OR time is different (more accurate comparison)
  # --parallel=N: upload N files in parallel (default 1, increase for speed)
  # --use-cache: use cache to speed up directory listings (lftp's internal cache)
  # Without --ignore-time or --ignore-size, mirror compares both size and time
  local mirror_cmd="mirror -R --parallel=3 --use-cache --verbose"
  
  # Add user-specified ignore patterns
  if [ -n "$IGNORE_DIR_OR_FILES" ]; then
    for pattern in $IGNORE_DIR_OR_FILES; do
      mirror_cmd="$mirror_cmd --exclude-glob $pattern"
      mirror_cmd="$mirror_cmd --exclude-glob $pattern/**"
    done
  fi
  mirror_cmd="$mirror_cmd $LOCAL_DIR ."
  
  debug_log "Final mirror command: $mirror_cmd"

  # Build lftp command with port
  # Use full path to lftp to avoid command not found issues
  local lftp_bin=$(command -v lftp)
  if [ -z "$lftp_bin" ]; then
    log::error "[$(timestamp)][ftp] lftp command not found in PATH."
    exit 1
  fi
  local lftp_cmd="$lftp_bin -u $FTP_USER,$FTP_PASS -p $FTP_PORT $FTP_HOST"
  
  # Build directory creation commands for REMOTE_DIR and its parents
  # Strategy: create directories level by level, but suppress error output
  # Since lftp doesn't support conditional execution, we create all levels
  # but errors are suppressed by redirecting stderr
  local dir_commands=""
  if [ "$REMOTE_DIR" != "/" ]; then
    # Split the path and handle each level
    IFS='/' read -ra ADDR <<< "$REMOTE_DIR"
    local current_path=""
    for part in "${ADDR[@]}"; do
      if [ -n "$part" ]; then
        if [ -z "$current_path" ]; then
          # Handle absolute path starting with /
          if [[ "$REMOTE_DIR" == /* ]]; then
            current_path="/$part"
          else
            current_path="$part"
          fi
        else
          current_path="$current_path/$part"
        fi
        # Create directory - errors will be suppressed by cmd:fail-exit false
        # and we'll redirect output in the lftp session
        dir_commands="${dir_commands}mkdir \"$current_path\""$'\n'
      fi
    done
  fi
  
  # Execute lftp upload using heredoc (lftp doesn't support -f option)
  # Redirect stderr to suppress mkdir errors for existing directories
  $lftp_cmd 2>/dev/null <<EOF
set ftp:list-options -a
set ssl:verify-certificate no
set cmd:fail-exit false
# Enable cache and incremental transfer settings
set cache:enable true
# Don't clobber - let mirror -n decide if file needs update
set xfer:clobber false
set xfer:use-temp-file false
# Ensure file comparison by size and time
# lftp mirror compares file size and modification time via FTP protocol
# - ftp:use-mdtm: use MDTM command to get remote file modification time
# - ftp:use-feat: use FEAT command to check server capabilities
# - lftp queries remote server for each file's size and time, then compares with local
# - This is a real-time comparison via FTP protocol, no local cache needed
set ftp:use-mdtm true
set ftp:use-feat true
# Compare file size strictly (default behavior)
# mirror will skip if file size and time match
# Create parent directories if needed (errors suppressed for existing dirs)
${dir_commands}
# Change to the remote directory
cd "$REMOTE_DIR"
# Execute mirror command
$mirror_cmd
quit
EOF

  local lftp_exit_code=$?
  
  if [ "$lftp_exit_code" != "0" ]; then
    log::error "[$(timestamp)][ftp] failed to upload."
    exit 1
  fi

  log::success "[$(timestamp)][ftp] succeed to upload."
}

run() {
  core $@
}

run $@
