#!/bin/bash

os::kernel() {
  echo $(uname -s)
}

os::is_macos() {
  local kernel=$(os::kernel)

  if [ "$kernel" = "Darwin" ]; then
    echo true
  else
    echo false
  fi
}

os::rw_permission() {
  local path=$1
  # if [ -f $path ]; then
  #   if  [ ! -r $path ] || [ ! -w $path ]; then
  #     sudo chmod o+rw $path
  #   fi
  # fi

  # if [ -d $path ]; then
  #   if [ ! -w $path ]; then
  #     sudo chown -R $(os::username) $path
  #   fi
  # fi

  # path not exist
  if [ ! -e $path ]; then
    return
  fi

  if [ ! -r $path ] || [ ! -w $path ]; then
    sudo chmod a+rw $path

    log::debug "add rw permission: $path"
  fi
}

os::ensure_permission() {
  os::rw_permission $@
}

# @TODO
os::ensure_logs_permission() {
  os::ensure_permission $ZMICRO_LOG_PATH

  os::ensure_permission $ZMICRO_LOG_COMMON_PATH
  os::ensure_permission $ZMICRO_LOG_DEBUG_PATH
  os::ensure_permission $ZMICRO_LOG_ERROR_PATH
  os::ensure_permission $ZMICRO_LOG_UPDATE_PATH
  os::ensure_permission $ZMICRO_LOG_VERSION_PATH
  os::ensure_permission $ZMICRO_LOG_NOTIFY_PATH
}

os::is_support_color() {
  # if [ "$(echo $PS1)" != "" ]; then
  if [ "$TERM" = "xterm-256color" ]; then
    echo "true"
  else
    echo "false"
  fi
}

# os::username() {
#   if [ "$GIT_USER" != "" ]; then
#     echo $GIT_USER
#     return
#   fi

#   if [ "$USER" != "" ]; then
#     echo $USER
#     return
#   fi

#   local user=$(id -u -n)
#   if [ "$user" != "" ]; then
#     echo $user
#     return
#   fi

#   log::error "Cannot get user by os::username"
#   exit 1
# }

array::join() {
  local seperator=$1
  local args=${@:2}

  if [ "$seperator" = "" ] || [ "$args" = "" ]; then
    log::error "seperator, args is required"
    exit 1
  fi

  if [ "$seperator" = "<>" ]; then
    seperator=""
  fi

  local res=""
  for element in $args; do
    if [ "$res" = "" ]; then
      res=$element
      continue
    fi

    res="${res}${seperator}${element}"
  done

  echo $res
}

help::list() {
  local help_commands_path=$1
  local command_prefix=${@:2}
  if [ ! -d $help_commands_path ]; then
    log::debug "[$(timestamp)][help::list] path is required"
    return
  fi

  echo "Usage:"
  echo ""
  echo "  ${command_prefix} [args...]"
  echo ""
  # echo $(ls $ZMICRO_COMMANDS_PATH)

  local help_commands=$(ls $help_commands_path)
  local help_command=""
  for help_command in $help_commands; do
    if [[ $help_command = _* ]]; then
      continue
    fi

    echo "         $help_command"
  done

  echo ""
}

path::is_file() {
  path=$1
  if [ -f $path ]; then
    return 0
  fi

  return 1
}

version::get() {
  local path=$1
  cd $path

  config::load_mod $path

  # @TODO REMOVE patch next version
  if [ "$PLUGIN_VERSION" ]; then
    export VERSION=$PLUGIN_VERSION
  fi

  echo $VERSION
}

version::zmicro() {
  version::get $ZMICRO_HOME
}

# # Usage:
# #   default mode: echo "$var" | fs::write $file_path
# #   append mode: echo "$var" | fs::write -a $file_path
# #
# # Example:
# #   echo "hi" | fs::write /tmp/hi
# #   echo "$HOME" | fs::write /tmp/hi
# #
# #   @NOTICE 当写入多行数据的时候，必须加引号，否则换行将消失
# #     text=$(cat <<-END
# #     line1
# #     line2
# #     line3
# #     END
# #     )
# #     GOOD: echo "$text" | fs::write /tmp/hi
# #     BAD: echo $text | fs::write /tmp/hi
# #
# fs::write() {
#   local path=$1
#   local is_append_mode=false
#   local text=$(</dev/stdin)

#   # @TODO
#   # fs::write -a /tmp/path
#   if [ "$path" = "-a" ]; then
#     path=$2
#     is_append_mode=true
#   fi

#   if [ "$2" = "true" ]; then
#     is_append_mode=true
#   fi

#   if [ -z "$path" ] || [ -z "$text" ]; then
#     log::error "[$(timestamp)][fs::write] path and text is required"
#     exit 1
#   fi

#   # if [ ! -f $path ]; then
#   #   log::error "[$(timestamp)][fs::write] path $path not found"
#   #   exit 1
#   # fi

#   # no permission
#   # try to use sudo/root
#   if [ ! -w $path ]; then
#     if [ "$is_append_mode" = "true" ]; then
#       sudo tee -a $path >>/dev/null <<EOF
# ${text}
# EOF
#     else
#       sudo tee $path >>/dev/null <<EOF
# ${text}
# EOF
#     fi
#     return
#   fi

#   if [ "$is_append_mode" = "true" ]; then
#     echo "$text" >>$path
#   else
#     echo "$text" >$path
#   fi
#   #     tee -a $path >> /dev/null <<EOF
#   # ${text}
#   # EOF
# }

# os::is_docker() {
#   if [ -f "/.dockerenv" ]; then
#     echo "true"
#     return
#   fi

#   if [ ! -f "/proc/self/cgroup" ]; then
#     echo "false"
#     return
#   fi

#   cat /proc/self/cgroup | grep docker >>/dev/null 2>&1
#   if [ "$?" = "0" ]; then
#     echo "true"
#     return
#   fi

#   echo "false"
# }

# git::fix_permissions() {
#   # fix unsafe repository
#   git config --global -l | grep "safe.directory=\*" >>/dev/null 2>&1
#   if [ "$?" != "0" ]; then
#     git config --global --add safe.directory "*"
#   fi
# }

export -f os::kernel
export -f os::is_macos

export -f os::rw_permission
export -f os::ensure_permission
export -f os::ensure_logs_permission

export -f os::is_support_color

# export -f os::username

# export -f os::is_docker

export -f array::join
export -f help::list
export -f path::is_file

export -f version::get
export -f version::zmicro

# export -f fs::write

# export -f git::fix_permissions
